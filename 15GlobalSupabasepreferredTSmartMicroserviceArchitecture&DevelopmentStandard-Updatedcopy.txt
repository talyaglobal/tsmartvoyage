# Global TSmart Microservice Architecture & Development Standard
This comprehensive document serves as the global standard for defining any 
TSmart application architecture, regardless of whether it's web or mobile-based. It 
consolidates all aspects of development, deployment, and infrastructure, ensuring 
consistent application of best practices across projects.
## 1. System Architecture Overview
### 1.1 Core Architecture Principles
TSmart applications follow a microservices-based architecture with containerized 
components, providing:
* **Scalability**: Independent scaling of services based on demand
* **Resilience**: Fault isolation and graceful degradation
* **Maintainability**: Modular development and deployment
* **Technology Flexibility**: Appropriate tech stack for each service
* **DevOps Integration**: CI/CD pipeline, monitoring, and automation
### 1.2 Containerization & Orchestration
All TSmart applications utilize:
* **Docker Containerization**: Consistent environments across development, testing, 
and production
* **Docker Compose**: For local development and single-instance deployments
* **Standard Infrastructure**: Pre-configured services for databases, frontend, 
backend, monitoring, and proxy
* **Container Registry**: Private registry for storing and versioning Docker images
* **Monitoring**: Comprehensive system for container and application metrics
## 2. Microservice Infrastructure Components
### 2.1 Core Services Stack
The standard microservice architecture includes:
#### 2.1.1 Reverse Proxy & API Gateway
* **Traefik**: Handles routing, load balancing, and TLS termination
* Automatic HTTPS with Let's Encrypt
* Service discovery via Docker labels
* Built-in metrics for monitoring
#### 2.1.2 Backend Services
* Containerized **Next.js 15+** APIs following RESTful principles, no src, app router approach
* Organized by domain/function
* Independent deployment and scaling
* Standardized error handling and logging
#### 2.1.3 Frontend Application
* **Next.js 15+** with App Router for web interfaces
* Responsive design supporting all target devices
* Containerized build and deployment process
#### 2.1.4 Database Services
• Database Abstraction Layer (DAL) implementation
  ◦ Provides a unified interface for all database interactions
  ◦ Allows for easy swapping between database systems without application code 
  changes
  ◦ Supports multiple database paradigms (document, relational, key-value)
• Supported Database Backends
  ◦ **Primary**: Supabase (PostgreSQL backend with enhanced features)
  ◦ Additional Support: Redis (for caching and key-value operations)
• ORM/ODM Integration
  ◦ Prisma ORM for Supabase interactions
  ◦ Repository pattern implementation for clean separation of concerns
  ◦ Query builder interface that generates optimized queries for each backend
• Connection Management
  ◦ Connection pooling configured per database type
  ◦ Automatic failover and retry mechanisms
  ◦ Read/write splitting capability for scalability
• Transaction Support
  ◦ Cross-database transaction management where possible
  ◦ Fallback to application-level transactions where native support is limited
• Migration System
  ◦ Schema version tracking across different database systems
  ◦ Automated migration scripts with database-specific implementations
  ◦ Rollback capabilities
• Caching Strategy
  ◦ Integrated caching with configurable backends (Redis, Memcached, inmemory)
  ◦ Cache invalidation hooks tied to data mutations
#### 2.1.5 Monitoring & Observability
* Prometheus for metrics collection
* Grafana for metrics visualization
* ELK Stack (Elasticsearch, Logstash, Kibana) for logging
* Node Exporter and cAdvisor for system/container metrics
#### 2.1.6 Deployment Management
* Watchtower for automatic container updates
* Health checks for all services
* Environment-specific configuration
## 3. Development Standards
### 3.1 SOLID Principles
All TSmart applications must adhere to SOLID principles:
* **Single Responsibility**: One primary responsibility per class/module/file
* **Open/Closed**: Extensible without modification of existing code
* **Liskov Substitution**: Subtypes must be substitutable for base types
* **Interface Segregation**: Clients should not depend on interfaces they don't use
* **Dependency Inversion**: Depend on abstractions, not concrete implementations
### 3.2 Backend Development Guidelines
#### 3.2.1 API Layer
* REST APIs with proper resource naming conventions
* Appropriate HTTP methods (GET, POST, PUT, DELETE, PATCH)
* Consistent JSON response formats with proper status codes
* Pagination for collection endpoints
#### 3.2.2 Validation
* **Runtime validation** is mandatory for all data entering the system
* For Supabase: Use Prisma schema validators and row-level security
* Enforce validation at the API handler level
#### 3.2.3 Error Handling
* Implement centralized error handling middleware
* Define and use custom error classes
* Log errors with appropriate context and stack traces
* Return standardized error responses
#### 3.2.4 Factory Functions
* Use factory functions or constructors for object instantiation
* Conform to standardized interface patterns
### 3.3 Database Standards
#### 3.3.1 Supabase (Preferred)
=ALL SUPABASES CONNECTIONS SHOULD BE ESTABLISHED ON REST API SERVICES INSTEAD OF SDK (USE FETCH, NOT AXIOS)
* Implement row-level security (RLS) policies
* Define schemas and relations through Prisma schema
* Leverage real-time subscription capabilities when needed
### 3.4 Frontend Development Guidelines
#### 3.4.1 Tech Stack
* **Framework**: Next.js 15+ with App Router
* **Styling**: Tailwind CSS with custom theme
* **State Management**: React Context API + React Query for server state
* **Authentication**: generic jwt authentication (Supabase Auth when using Supabase)
* **Components**: Shadcn UI as component library foundation
* **Language**: TypeScript
#### 3.4.2 Design System
* **Color Palette**
 * Primary: Deep blue (`#1a365d`)
 * Secondary: Gold accent (`#c4a450`)
 * Success: Emerald green (`#059669`)
 * Warning: Amber (`#d97706`)
 * Danger: Crimson (`#dc2626`)
 * Background: Off-white to white gradient (`#f8fafc` to `#ffffff`)
* **Typography**
 * Sans-serif font for interface elements (Inter)
 * Serif font for legal document previews (Merriweather)
 * Monospace for code sections (JetBrains Mono)
* **Spacing System**
 * Follow 4px grid (4px, 8px, 16px, 24px, 32px, 48px, 64px)
* **Shadows & Borders**
 * Subtle depth for cards and interactive elements
 * 1px with 4px radius for most elements, 8px for cards
## 4. Prompt Template for Application Generation
```
Generate a [backend module/frontend component] for a TSmart application following 
the global standard.
**Context:**
- Target: [Backend (Next.js 15+) / Frontend (Next.js 15+)]
- Database: Supabase (preferred) / 
- Feature: [Describe the specific feature or component to be created]
**Requirements:**
- Adhere to SOLID principles
- Follow TSmart UI design system (for frontend)
- Ensure TypeScript usage with clear types
- Implement proper error handling and logging
- Follow the containerization approach from the global standard
**Desired Output:**
- [Describe expected code structure and files]
```
## 5. Key Enhancement Test, Recommendations for Review, Deploy Final
Review your code as per five key areas where the TSmart architecture could be enhanced by 
adopting patterns from your schema:
1. Schema Validation and Data Integrity
   ◦ Incorporating comprehensive field-level validation with specific patterns, 
   lengths, and types
   ◦ Implementing strict validation rules at the database level
   ◦ Providing clear documentation through self-documenting schemas
2. Collection Relationships and Referential Integrity
   ◦ Explicit parent-child relationship definitions
   ◦ Field mapping between related collections
   ◦ Conditional filtering of parent records
   ◦ Selective field retrieval from parent collections
3. Workflow Automation and Business Rules
   ◦ Declarative action framework with conditional execution
   ◦ External API integration patterns
   ◦ Condition-based data modifications
   ◦ User interface integration via button text and icons
4. Notification and Integration Patterns
   ◦ Structured notification templates
   ◦ Dynamic content with field substitution
   ◦ Multi-format support (HTML, attachments)
   ◦ Cross-collection operations for complex business processes
5. Advanced Data Indexing Strategy
   ◦ Declarative indexing configuration
   ◦ Compound index definitions
   ◦ Uniqueness constraints
   ◦ Default sort ordering
## 6. Conclusion
This Global TSmart Microservice Architecture Standard provides a comprehensive 
blueprint for consistent application development and deployment. By adhering to 
these guidelines, teams can ensure:
* Consistent application structure and code quality
* Scalable and maintainable microservice architecture
* Secure and performant applications
* Simplified deployment and operations
* Consistent user experience across all TSmart applications